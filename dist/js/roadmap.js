// Generated by CoffeeScript 1.7.1
(function() {
  var defaults, extend,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  defaults = {
    width: 480,
    height: 400,
    miniheight: 100,
    minirangeleft: 56,
    minirangeright: 360,
    margin: {
      top: 20,
      right: 30,
      bottom: 30,
      left: 40
    },
    lineheight: 20,
    range_back: 14,
    range_forward: 28
  };

  extend = function(destination, source) {
    var property, _i, _len, _ref;
    _ref = Object.keys(source);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      property = _ref[_i];
      destination[property] = source[property];
    }
    return destination;
  };

  this.RoadmapD3 = (function() {
    function RoadmapD3(target, options) {
      var self;
      this.target = target;
      if (options == null) {
        options = {};
      }
      this.options = extend(defaults, options);
      self = this;
      window.onresize = function(e) {
        return self.update_window(e, self);
      };
    }

    RoadmapD3.prototype.update_window = function(e, self) {
      var x;
      x = $(".chart").parent().parent().width();
      self.options.width = x;
      $(self.target).empty();
      return self.draw(self.lastdata);
    };

    RoadmapD3.prototype.zoomed = function() {
      var mrange, x1, x2;
      this.svg.select(".x.axis").call(this.xAxis);
      d3.event.translate[1] = 0;
      console.log(d3.event.translate);
      this.graph.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ", 1)");
      mrange = this.get_main_range();
      x1 = this.miniXaxis.scale()(mrange[0]);
      x2 = this.miniXaxis.scale()(mrange[1]);
      return this.minisvg.select(".glasswindow").attr("x", x1).attr("width", x2 - x1);
    };

    RoadmapD3.prototype.get_main_range = function() {
      var mainrange, scale;
      scale = this.xAxis.scale();
      mainrange = [];
      mainrange.push(scale.invert(scale.range()[0]));
      mainrange.push(scale.invert(scale.range()[1]));
      console.log("timerange " + mainrange);
      return mainrange;
    };

    RoadmapD3.prototype.move_to = function(x, node) {
      var scale;
      scale = this.zoom.scale();
      this.zoom.translate([x * scale, 0]);
      return this.zoom.event(node);
    };

    RoadmapD3.prototype.resize = function(width, height) {
      return this.graph.attr("transform", "translate(" + width + ", " + height + ")");
    };

    RoadmapD3.prototype.get_data_range = function(data) {
      return [
        d3.min(data, function(d) {
          return new Date(d.startdate);
        }), d3.max(data, function(d) {
          return new Date(d.enddate);
        })
      ];
    };

    RoadmapD3.prototype.get_time_range = function(back, forward) {
      var backtime, forwardtime;
      if (back == null) {
        back = 7;
      }
      if (forward == null) {
        forward = 7;
      }
      backtime = new Date;
      forwardtime = new Date;
      backtime.setDate(backtime.getDate() - back);
      forwardtime.setDate(forwardtime.getDate() + forward);
      return [backtime, forwardtime];
    };

    RoadmapD3.prototype.get_groups = function(data) {
      var group, groupdicts, groupname, grouppos, groups, item, _i, _j, _len, _len1, _ref;
      groups = [];
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        item = data[_i];
        if (_ref = item.group, __indexOf.call(groups, _ref) < 0) {
          groups.push(item.group);
        }
      }
      groups.sort();
      this.groupheight = this.height / groups.length;
      grouppos = 0;
      groupdicts = [];
      for (_j = 0, _len1 = groups.length; _j < _len1; _j++) {
        groupname = groups[_j];
        group = {
          name: groupname,
          index: grouppos,
          ypos: grouppos * this.groupheight,
          height: this.groupheight
        };
        groupdicts.push(group);
        grouppos++;
      }
      return groupdicts;
    };

    RoadmapD3.prototype.validate_data = function(data) {
      var item, _i, _len, _results;
      this.lastdata = data;
      _results = [];
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        item = data[_i];
        if (typeof item.startdate === 'string') {
          item.startdate = new Date(item.startdate);
        }
        if (typeof item.enddate === 'string') {
          item.enddate = new Date(item.enddate);
        }
        if (item.startdate == null) {
          console.log("Item '" + item.name + "' has no startdate!");
        }
        if (item.enddate == null) {
          console.log("Item '" + item.name + "' has no enddate!");
          item.enddate = new Date(item.startdate);
          _results.push(item.enddate.setDate(item.enddate.getDate() + 7));
        } else if (item.enddate < item.startdate) {
          console.log("Item '" + item.name + "' enddate < startdate!");
          item.enddate = new Date(item.startdate);
          _results.push(item.enddate.setDate(item.enddate.getDate() + 7));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    RoadmapD3.prototype.create_axis = function(rangex, height, width, format) {
      var axis, formatWeek, x;
      if (format == null) {
        format = null;
      }
      x = d3.time.scale().range([0, width]);
      formatWeek = function(d) {
        if (format == null) {
          format = d3.time.format("%U.%w");
        }
        return "Week " + (format(d));
      };
      axis = d3.svg.axis().scale(x).tickSize(height).tickFormat(formatWeek);
      x.domain(rangex);
      return axis;
    };

    RoadmapD3.prototype.draw = function(data) {
      var blocks, nodes, now, nowx, self, xscale;
      self = this;
      this.validate_data(data);
      this.width = this.options.width;
      this.height = this.options.height;
      this.rangex = this.get_time_range(this.options.range_back, this.options.range_forward);
      this.xAxis = this.create_axis(this.rangex, this.height - this.options.margin.bottom, this.width);
      this.groups = this.get_groups(data);
      this.draw_mini(data);
      this.zoom = d3.behavior.zoom().x(this.xAxis.scale()).scaleExtent([0, 10]).on("zoom", function() {
        return self.zoomed();
      });
      this.svg = d3.select(self.target).append("svg").attr("width", this.width).attr("height", this.height).call(this.zoom);
      this.draw_groups(this.groups);
      this.graph = this.svg.append("g").attr("class", "chart");
      this.graph.append("g").attr("transform", "translate(" + 0 + "," + 0 + ")");
      xscale = this.xAxis.scale();
      now = new Date;
      nowx = xscale(now);
      this.graph.append("line").attr("x1", nowx).attr("y1", 0).attr("x2", nowx).attr("y2", this.height - this.options.margin.bottom).attr("stroke", "red");
      blocks = this.count_blocks(data, xscale, this.height - this.options.margin.bottom, this.options.lineheight);
      nodes = this.draw_blocks(this.graph, blocks);
      this.add_node_events(nodes);
      return this.svg.append("g").attr("class", "x axis").attr("stroke-dasharray", "2,2").call(this.xAxis);
    };

    RoadmapD3.prototype.draw_groups = function(groups) {
      var groupnodes;
      groupnodes = this.svg.selectAll("g.group").data(groups).enter().append("g").attr("class", "group").attr("transform", function(d) {
        return "translate(" + 0 + "," + d.ypos + ")";
      });
      groupnodes.append("rect").attr("class", function(d) {
        if (d.index % 2 === 0) {
          return "group even";
        } else {
          return "group odd";
        }
      }).attr("fill-opacity", "0.4").attr("width", this.width).attr("height", function(d) {
        return d.height;
      });
      return groupnodes.append("text").attr("class", "group").attr("dy", "1em").attr("dx", "1em").attr("font-size", "2em").text(function(d) {
        return d.name;
      });
    };

    RoadmapD3.prototype.get_group = function(name) {
      var group, _i, _len, _ref;
      _ref = this.groups;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        group = _ref[_i];
        if (group.name === name) {
          return group;
        }
      }
      return null;
    };

    RoadmapD3.prototype.count_blocks = function(data, xscale, height, lineheight) {
      var block, blocks, bpos, item, x1, x2, ypos, _i, _len;
      blocks = [];
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        item = data[_i];
        x1 = xscale(item.startdate);
        x2 = xscale(item.enddate);
        ypos = this.get_group(item.group).ypos;
        bpos = 0;
        block = {
          name: item.name,
          x: x1,
          y: ypos,
          index: bpos,
          height: lineheight,
          width: x2 - x1,
          item: item
        };
        blocks.push(block);
      }
      return blocks;
    };

    RoadmapD3.prototype.count_mini_blocks = function(data, xscale, height, lineheight) {
      var block, blocks, bpos, item, x1, x2, ypos, _i, _len;
      blocks = [];
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        item = data[_i];
        x1 = xscale(item.startdate);
        x2 = xscale(item.enddate);
        ypos = 10;
        bpos = 0;
        block = {
          name: item.name,
          x: x1,
          y: ypos,
          index: bpos,
          height: lineheight,
          width: x2 - x1,
          item: item
        };
        blocks.push(block);
      }
      return blocks;
    };

    RoadmapD3.prototype.draw_blocks = function(graph, blocks) {
      var mynodes, nodes, self;
      self = this;
      nodes = graph.selectAll("rect").data(blocks).enter().append("g").attr("class", "node").attr("transform", function(d) {
        return "translate(" + d.x + "," + d.y + ")";
      });
      nodes.append("title").text(function(d) {
        return d.name;
      });
      nodes.append("rect").attr("class", "block").attr("width", function(d) {
        return d.width;
      }).attr("height", function(d) {
        return d.height;
      }).attr("rx", "10");
      nodes.append("text").attr("class", "block").attr("dx", "1em").attr("dy", "1em").text(function(d) {
        return d.name;
      });
      mynodes = nodes;
      nodes.each(function(d, index) {
        var curbox, current, i, node, nodebox, x1, x2, _i;
        current = mynodes[0][index];
        curbox = current.getBBox();
        x1 = current.__data__.x;
        x2 = current.__data__.x + curbox.width;
        for (i = _i = 0; 0 <= index ? _i <= index : _i >= index; i = 0 <= index ? ++_i : --_i) {
          node = mynodes[0][i];
          nodebox = node.getBBox();
          if (i !== index) {
            if (node.__data__.x <= x1 && x1 <= node.__data__.x + nodebox.width || node.__data__.x <= x2 && x2 <= node.__data__.x + nodebox.width) {
              current.__data__.y += nodebox.height;
            }
          }
        }
        d3.select(current).attr("transform", function(d) {
          return "translate(" + d.x + "," + d.y + ")";
        });
      });
      return nodes;
    };

    RoadmapD3.prototype.add_node_events = function(nodes) {
      var self;
      self = this;
      nodes.on("mouseover", function(d, i) {
        return d3.select(this).select('rect').classed("highlight", true);
      });
      nodes.on("mouseout", function(d, i) {
        return d3.select(this).select('rect').classed("highlight", false);
      });
      nodes.on("click", function(d, i) {
        var node;
        node = nodes[0][i];
        d3.select('.selected').classed('selected', false);
        d3.select(node).select('rect').classed('selected', true);
        return $(self).trigger("select", {
          data: d,
          node: node
        });
      });
    };

    RoadmapD3.prototype.draw_mini = function(data) {
      var blocks, graph, move_window, mrange, nodes, rangex, self, view, viewdrag, x1, x2, xscale;
      self = this;
      this.minisvg = d3.select(this.target).append("svg").attr("width", this.width).attr("height", this.options.miniheight).attr("class", "miniview");
      rangex = this.get_time_range(this.options.minirangeleft, this.options.minirangeright);
      this.miniXaxis = this.create_axis(rangex, this.options.miniheight - 20, this.width, d3.time.format("%U"));
      this.minisvg.append("g").attr("class", "x axis").attr("stroke-dasharray", "2,2").call(this.miniXaxis);
      mrange = this.get_main_range();
      x1 = this.miniXaxis.scale()(mrange[0]);
      x2 = this.miniXaxis.scale()(mrange[1]);
      viewdrag = d3.behavior.drag();
      view = this.minisvg.append("g").append("rect").attr("class", "glasswindow").attr("fill-opacity", "0.4").attr("x", x1).attr("width", x2 - x1).attr("height", this.options.miniheight).call(viewdrag);
      graph = this.minisvg.append("g");
      xscale = this.miniXaxis.scale();
      blocks = this.count_mini_blocks(data, xscale, this.options.miniheight - this.options.margin.bottom, 3);
      nodes = this.draw_blocks(graph, blocks);
      move_window = function() {
        var mainleft, mainx, newx, xpos, xtime, zscale;
        xpos = d3.mouse(this)[0];
        xtime = self.miniXaxis.scale().invert(xpos);
        mainx = self.xAxis.scale()(xtime);
        zscale = self.zoom.scale();
        mainleft = self.zoom.translate()[0];
        newx = (mainleft - mainx) / zscale;
        console.log("" + xpos + ", " + zscale + ", " + mainleft + " " + mainx + " " + newx);
        return self.move_to(newx, d3.select(".glasswindow"));
      };
      viewdrag.on("drag", move_window);
      return this.minisvg.on("click", move_window);
    };

    return RoadmapD3;

  })();

}).call(this);
