// Generated by CoffeeScript 1.9.3
(function() {
  var Group, OrderedDict, Project, RoadmapModel, defaults, extend,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  defaults = {
    width: 480,
    miniheight: 100,
    minirangeleft: 56,
    minirangeright: 360,
    margin: {
      top: 20,
      right: 30,
      bottom: 30,
      left: 40
    },
    lineheight: 20,
    range_back: 14,
    range_forward: 28
  };

  extend = function(destination, source) {
    var k, len, property, ref;
    ref = Object.keys(source);
    for (k = 0, len = ref.length; k < len; k++) {
      property = ref[k];
      destination[property] = source[property];
    }
    return destination;
  };

  Date.prototype.getWeekNumber = function() {
    var d;
    d = new Date(+this);
    d.setHours(0, 0, 0);
    d.setDate(d.getDate() + 4 - (d.getDay() || 7));
    return Math.ceil((((d - new Date(d.getFullYear(), 0, 1)) / 8.64e7) + 1) / 7) + 1;
  };

  OrderedDict = (function() {
    function OrderedDict(keyname) {
      this.keyname = keyname;
      this.order = [];
      this.data = {};
    }

    OrderedDict.prototype.append = function(item) {
      var id;
      id = item[this.keyname];
      this.data[id] = item;
      if (indexOf.call(this.order, id) < 0) {
        return this.order.push(id);
      }
    };

    OrderedDict.prototype.insert = function(index, item) {
      var id;
      id = item[this.keyname];
      if (indexOf.call(this.order, id) >= 0) {
        index = this.order.indexOf(id);
        this.order.splice(index, 1);
      }
      this.data[id] = item;
      return this.order.splice(index, 0, id);
    };

    OrderedDict.prototype.keys = function() {
      var id, k, len, ref, results;
      ref = this.order;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        id = ref[k];
        results.push(id);
      }
      return results;
    };

    OrderedDict.prototype.list = function() {
      var id, k, len, ref, results;
      ref = this.order;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        id = ref[k];
        results.push(this.data[id]);
      }
      return results;
    };

    OrderedDict.prototype.get = function(id) {
      return this.data[id];
    };

    OrderedDict.prototype.has = function(id) {
      return indexOf.call(this.order, id) >= 0;
    };

    OrderedDict.prototype.pop = function(id) {
      var item;
      item = this.data[id];
      this.remove(id);
      return item;
    };

    OrderedDict.prototype.top = function() {
      return this.data[this.order[this.order.length - 1]];
    };

    OrderedDict.prototype.remove = function(id) {
      var index;
      index = this.order.indexOf(id);
      if (index === -1) {
        throw Error("item " + id + " not found!");
      } else {
        this.order.splice(index, 1);
        return delete this.data[id];
      }
    };

    OrderedDict.prototype.empty = function(id) {
      this.order = [];
      return this.data = {};
    };

    return OrderedDict;

  })();

  Group = (function() {
    function Group(name) {
      this.name = name;
      this.projects = new OrderedDict("name");
      this.y = 0;
      this.height = 0;
    }

    Group.prototype.add_project = function(project) {
      return this.projects.append(project);
    };

    Group.prototype.max_layers = function() {
      var k, len, overlaps, prj, ref;
      overlaps = [];
      ref = this.projects.list();
      for (k = 0, len = ref.length; k < len; k++) {
        prj = ref[k];
        overlaps.push(prj.overlapcount);
      }
      return Math.max.apply(null, overlaps);
    };

    return Group;

  })();

  Project = (function() {
    function Project(name, group1, data1) {
      this.name = name;
      this.group = group1;
      this.data = data1;
      this.start = this.data.startdate;
      this.end = this.data.enddate;
      this.overlapcount = 0;
    }

    Project.prototype.overlaps = function(other) {
      if (other.start <= this.start && this.start <= other.end || other.start <= this.end && this.end <= other.end) {
        return true;
      }
    };

    return Project;

  })();

  RoadmapModel = (function() {
    function RoadmapModel() {
      this.groups = new OrderedDict("name");
    }

    RoadmapModel.prototype.add_data = function(data) {
      var group, item, k, len, project, ref;
      for (k = 0, len = data.length; k < len; k++) {
        item = data[k];
        if (ref = item.group, indexOf.call(this.groups.keys(), ref) < 0) {
          this.groups.append(new Group(item.group));
        }
        group = this.groups.get(item.group);
        project = new Project(item.name, group, item);
        console.log("Adding project " + item.name);
        group.add_project(project);
      }
      return this.groups.order.sort();
    };

    RoadmapModel.prototype.calculate = function() {
      var group, i, j, k, len, other, project, projects, ref, results;
      ref = this.groups.list();
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        group = ref[k];
        projects = group.projects.list();
        results.push((function() {
          var l, ref1, results1;
          results1 = [];
          for (i = l = 0, ref1 = projects.length - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; i = 0 <= ref1 ? ++l : --l) {
            project = projects[i];
            results1.push((function() {
              var m, ref2, results2;
              results2 = [];
              for (j = m = 0, ref2 = i; 0 <= ref2 ? m <= ref2 : m >= ref2; j = 0 <= ref2 ? ++m : --m) {
                other = projects[j];
                if (project !== other) {
                  if (project.overlaps(other)) {
                    results2.push(project.overlapcount++);
                  } else {
                    results2.push(void 0);
                  }
                } else {
                  results2.push(void 0);
                }
              }
              return results2;
            })());
          }
          return results1;
        })());
      }
      return results;
    };

    RoadmapModel.prototype.debug = function() {
      var group, k, len, project, ref, results;
      ref = this.groups.list();
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        group = ref[k];
        console.log("Group: " + group.name + ", max_layers " + (group.max_layers()));
        results.push((function() {
          var l, len1, ref1, results1;
          ref1 = group.projects.list();
          results1 = [];
          for (l = 0, len1 = ref1.length; l < len1; l++) {
            project = ref1[l];
            results1.push(console.log("  Prj: " + project.name));
          }
          return results1;
        })());
      }
      return results;
    };

    RoadmapModel.prototype.get_group_dicts = function(groups) {
      var group, groupdicts, groupname, grouppos, k, len;
      this.groupheight = this.height / groups.length;
      grouppos = 0;
      groupdicts = [];
      for (k = 0, len = groups.length; k < len; k++) {
        groupname = groups[k];
        group = {
          name: groupname,
          index: grouppos,
          ypos: grouppos * this.groupheight,
          height: this.groupheight
        };
        groupdicts.push(group);
        grouppos++;
      }
      return groupdicts;
    };

    RoadmapModel.prototype.add_blocks = function(data, xscale, height, lineheight) {
      var block, blocks, bpos, group, item, k, len, x1, x2;
      blocks = [];
      for (k = 0, len = data.length; k < len; k++) {
        item = data[k];
        x1 = xscale(item.startdate);
        x2 = xscale(item.enddate);
        group = this.get_group(item.group);
        bpos = 0;
        block = {
          name: item.name,
          x: x1,
          y: group.ypos,
          gpos: group.index,
          height: lineheight,
          width: x2 - x1,
          item: item
        };
        blocks.push(block);
      }
      return blocks;
    };

    RoadmapModel.prototype.create_model = function(data) {
      return this.add_data(data);
    };

    return RoadmapModel;

  })();

  this.RoadmapD3 = (function() {
    function RoadmapD3(target, options) {
      var self;
      this.target = target;
      if (options == null) {
        options = {};
      }
      this.options = extend(defaults, options);
      this.model = new RoadmapModel();
      self = this;
      window.onresize = function(e) {
        return self.update_window(e, self);
      };
    }

    RoadmapD3.prototype.update_window = function(e, self) {
      var x;
      x = $(".chart").parent().parent().width();
      self.options.width = x;
      $(self.target).empty();
      return self.draw(self.lastdata);
    };

    RoadmapD3.prototype.zoomed = function() {
      var mrange, x1, x2;
      this.svg.select(".x.axis").call(this.xAxis);
      d3.event.translate[1] = 0;
      console.log(d3.event.translate);
      this.graph.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ", 1)");
      mrange = this.get_main_range();
      x1 = this.miniXaxis.scale()(mrange[0]);
      x2 = this.miniXaxis.scale()(mrange[1]);
      return this.minisvg.select(".glasswindow").attr("x", x1).attr("width", x2 - x1);
    };

    RoadmapD3.prototype.get_main_range = function() {
      var mainrange, scale;
      scale = this.xAxis.scale();
      mainrange = [];
      mainrange.push(scale.invert(scale.range()[0]));
      mainrange.push(scale.invert(scale.range()[1]));
      console.log("timerange " + mainrange);
      return mainrange;
    };

    RoadmapD3.prototype.move_to = function(x, node) {
      var scale;
      scale = this.zoom.scale();
      this.zoom.translate([x * scale, 0]);
      return this.zoom.event(node);
    };

    RoadmapD3.prototype.resize = function(width, height) {
      return this.graph.attr("transform", "translate(" + width + ", " + height + ")");
    };

    RoadmapD3.prototype.get_data_range = function(data) {
      return [
        d3.min(data, function(d) {
          return new Date(d.startdate);
        }), d3.max(data, function(d) {
          return new Date(d.enddate);
        })
      ];
    };

    RoadmapD3.prototype.get_time_range = function(back, forward) {
      var backtime, forwardtime;
      if (back == null) {
        back = 7;
      }
      if (forward == null) {
        forward = 7;
      }
      backtime = new Date;
      forwardtime = new Date;
      backtime.setDate(backtime.getDate() - back);
      forwardtime.setDate(forwardtime.getDate() + forward);
      return [backtime, forwardtime];
    };

    RoadmapD3.prototype.validate_data = function(data) {
      var item, k, len, results;
      this.lastdata = data;
      results = [];
      for (k = 0, len = data.length; k < len; k++) {
        item = data[k];
        if (typeof item.startdate === 'string') {
          item.startdate = new Date(item.startdate);
        }
        if (typeof item.enddate === 'string') {
          item.enddate = new Date(item.enddate);
        }
        if (item.startdate == null) {
          console.log("Item '" + item.name + "' has no startdate!");
        }
        if (item.enddate == null) {
          console.log("Item '" + item.name + "' has no enddate!");
          item.enddate = new Date(item.startdate);
          results.push(item.enddate.setDate(item.enddate.getDate() + 7));
        } else if (item.enddate < item.startdate) {
          console.log("Item '" + item.name + "' enddate < startdate!");
          item.enddate = new Date(item.startdate);
          results.push(item.enddate.setDate(item.enddate.getDate() + 7));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    RoadmapD3.prototype.create_axis = function(rangex, height, width, formatWeek) {
      var axis, x;
      if (formatWeek == null) {
        formatWeek = null;
      }
      x = d3.time.scale().range([0, width]);
      if (formatWeek == null) {
        formatWeek = function(d) {
          var df;
          if (d.getDay() === 0) {
            return "Week " + (d.getWeekNumber());
          } else {
            df = d3.time.format("%a");
            return "" + (df(d));
          }
        };
      }
      axis = d3.svg.axis().scale(x).tickSize(height).tickFormat(formatWeek);
      x.domain(rangex);
      return axis;
    };

    RoadmapD3.prototype.draw = function(data) {
      var background, backheight, captions, chartheight, nodes, now, nowx, self, xscale;
      self = this;
      this.validate_data(data);
      this.width = this.options.width;
      this.height = this.options.height;
      this.rangex = this.get_time_range(this.options.range_back, this.options.range_forward);
      this.xAxis = this.create_axis(this.rangex, 5, this.width);
      xscale = this.xAxis.scale();
      this.model.create_model(data);
      this.model.calculate();
      this.model.debug();
      this.draw_mini(this.model);
      this.zoom = d3.behavior.zoom().x(this.xAxis.scale()).scaleExtent([0, 10]).on("zoom", function() {
        return self.zoomed();
      });
      this.svg = d3.select(self.target).append("svg").attr("width", this.width).call(this.zoom);
      background = this.svg.append("g").attr("class", "background");
      this.graph = this.svg.append("g").attr("class", "chart");
      captions = this.svg.append("g").attr("class", "captions");
      this.draw_groups(this.graph, this.model, xscale);
      nodes = this.graph.selectAll('.node');
      this.add_node_events(nodes);
      backheight = background[0][0].getBBox().height;
      chartheight = this.graph[0][0].getBBox().height;
      this.height = backheight + this.options.margin.bottom;
      captions.append("g").attr("class", "x axis").attr("stroke-dasharray", "2,2").attr("transform", "translate(" + 0 + "," + backheight + ")").call(this.xAxis);
      this.svg.attr("height", this.height);
      now = new Date;
      nowx = xscale(now);
      return this.graph.append("line").attr("stroke-dasharray", "2,2").attr("x1", nowx).attr("y1", 0).attr("x2", nowx).attr("y2", backheight).attr("stroke", "red");
    };

    RoadmapD3.prototype.draw_groups = function(graph, model, xscale) {
      var background, block, captions, group, groupgraph, groups, i, k, l, len, prevgroup, project, ref, ref1;
      groups = model.groups.list();
      for (i = k = 0, ref = groups.length - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
        group = groups[i];
        group.index = i;
        groupgraph = graph.append('g');
        ref1 = group.projects.list();
        for (l = 0, len = ref1.length; l < len; l++) {
          project = ref1[l];
          block = this.get_block(project, xscale);
          this.draw_block(groupgraph, block, this.options.lineheight);
        }
        if (i > 0) {
          prevgroup = groups[i - 1];
          group.y = prevgroup.y + prevgroup.height;
        } else {
          group.y = 0;
        }
        group.height = groupgraph[0][0].getBBox().height + 10;
        groupgraph.attr("transform", "translate(" + 0 + "," + group.y + ")");
      }
      background = this.svg.select('.background');
      captions = this.svg.select('.captions');
      background.selectAll("g.group").data(groups).enter().append("g").attr("class", "group").attr("transform", function(d) {
        return "translate(" + 0 + "," + d.y + ")";
      }).append("rect").attr("class", function(d) {
        if (d.index % 2 === 0) {
          return "group even";
        } else {
          return "group odd";
        }
      }).attr("width", this.width).attr("height", function(d) {
        return d.height;
      });
      captions.selectAll("g.group").data(groups).enter().append("g").attr("class", "group").attr("transform", function(d) {
        return "translate(" + 0 + "," + d.y + ")";
      }).append("text").attr("class", "group").attr("dy", "1em").attr("dx", "1em").attr("font-size", "2em").text(function(d) {
        return d.name;
      });
    };

    RoadmapD3.prototype.get_block = function(prj, xscale) {
      var block, x1, x2;
      x1 = xscale(prj.start);
      x2 = xscale(prj.end);
      return block = {
        name: prj.name,
        x: x1,
        y: 5,
        layer: prj.overlapcount,
        width: x2 - x1,
        prj: prj
      };
    };

    RoadmapD3.prototype.draw_block = function(graph, block, lineheight) {
      var box, g, gbox, k, len, newy, node, ref, self, x1, x2;
      self = this;
      node = graph.append("g").attr("class", "node");
      node.append("title").text(block.name);
      node.append("rect").attr("class", "block").attr("width", block.width).attr("height", lineheight).attr("rx", "10");
      node.append("text").attr("class", "block").attr("dx", "1em").attr("dy", "1em").text(block.name);
      node[0][0].__data__ = block;
      box = node[0][0].getBBox();
      ref = graph.selectAll('g')[0];
      for (k = 0, len = ref.length; k < len; k++) {
        g = ref[k];
        if (g.__data__ !== block) {
          gbox = g.getBBox();
          x1 = block.x;
          x2 = block.x + box.width;
          if (g.__data__.x <= x1 && x1 <= g.__data__.x + gbox.width || g.__data__.x <= x2 && x2 <= g.__data__.x + gbox.width) {
            newy = g.__data__.y + gbox.height;
            if (newy >= block.y) {
              block.y = newy;
            }
          }
        }
      }
      node.attr("transform", "translate(" + block.x + "," + block.y + ")");
    };

    RoadmapD3.prototype.count_mini_blocks = function(model, xscale, height) {
      var block, blocks, group, k, l, len, len1, prj, ref, ref1, x1, x2;
      blocks = [];
      ref = model.groups.list();
      for (k = 0, len = ref.length; k < len; k++) {
        group = ref[k];
        ref1 = group.projects.list();
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          prj = ref1[l];
          x1 = xscale(prj.start);
          x2 = xscale(prj.end);
          block = {
            name: prj.name,
            x: x1,
            y: 8,
            layer: prj.overlapcount,
            width: x2 - x1,
            prj: prj
          };
          blocks.push(block);
        }
      }
      return blocks;
    };

    RoadmapD3.prototype.draw_blocks = function(graph, blocks, lineheight) {
      var box, d, g, gbox, k, l, len, len1, newy, node, ref, self, x1, x2;
      self = this;
      for (k = 0, len = blocks.length; k < len; k++) {
        d = blocks[k];
        node = graph.append("g").attr("class", "node");
        node.append("title").text(d.name);
        node.append("rect").attr("class", "block").attr("width", d.width).attr("height", lineheight).attr("rx", "10");
        node.append("text").attr("class", "block").attr("dx", "1em").attr("dy", "1em").text(d.name);
        node[0][0].__data__ = d;
        box = node[0][0].getBBox();
        ref = graph.selectAll('g')[0];
        for (l = 0, len1 = ref.length; l < len1; l++) {
          g = ref[l];
          if (g.__data__ !== d) {
            gbox = g.getBBox();
            x1 = d.x;
            x2 = d.x + box.width;
            if (g.__data__.x <= x1 && x1 <= g.__data__.x + gbox.width || g.__data__.x <= x2 && x2 <= g.__data__.x + gbox.width) {
              newy = g.__data__.y + gbox.height;
              if (newy >= d.y) {
                d.y = newy;
              }
            }
          }
        }
        node.attr("transform", "translate(" + d.x + "," + d.y + ")");
      }
    };

    RoadmapD3.prototype.add_node_events = function(nodes) {
      var self;
      self = this;
      nodes.on("mouseover", function(d, i) {
        return d3.select(this).select('rect').classed("highlight", true);
      });
      nodes.on("mouseout", function(d, i) {
        return d3.select(this).select('rect').classed("highlight", false);
      });
      nodes.on("click", function(d, i) {
        var node;
        node = nodes[0][i];
        d3.select('.selected').classed('selected', false);
        d3.select(node).select('rect').classed('selected', true);
        return $(self).trigger("select", {
          data: d,
          node: node
        });
      });
    };

    RoadmapD3.prototype.draw_mini = function(model) {
      var blocks, formatMiniWeek, graph, move_window, mrange, nodes, rangex, self, view, viewdrag, x1, x2, xscale;
      self = this;
      this.minisvg = d3.select(this.target).append("svg").attr("width", this.width).attr("height", this.options.miniheight).attr("class", "miniview");
      rangex = this.get_time_range(this.options.minirangeleft, this.options.minirangeright);
      formatMiniWeek = function(d) {
        return "Week " + (d.getWeekNumber());
      };
      this.miniXaxis = this.create_axis(rangex, this.options.miniheight - 20, this.width, formatMiniWeek);
      this.minisvg.append("g").attr("class", "x axis").attr("stroke-dasharray", "2,2").call(this.miniXaxis);
      mrange = this.get_main_range();
      x1 = this.miniXaxis.scale()(mrange[0]);
      x2 = this.miniXaxis.scale()(mrange[1]);
      viewdrag = d3.behavior.drag();
      view = this.minisvg.append("g").append("rect").attr("class", "glasswindow").attr("fill-opacity", "0.4").attr("x", x1).attr("width", x2 - x1).attr("height", this.options.miniheight).call(viewdrag);
      graph = this.minisvg.append("g");
      xscale = this.miniXaxis.scale();
      blocks = this.count_mini_blocks(model, xscale, this.options.miniheight - this.options.margin.bottom);
      nodes = this.draw_blocks(graph, blocks, 3);
      move_window = function() {
        var mainleft, mainx, newx, xpos, xtime, zscale;
        xpos = d3.mouse(this)[0];
        xtime = self.miniXaxis.scale().invert(xpos);
        mainx = self.xAxis.scale()(xtime);
        zscale = self.zoom.scale();
        mainleft = self.zoom.translate()[0];
        newx = (mainleft - mainx) / zscale;
        console.log(xpos + ", " + zscale + ", " + mainleft + " " + mainx + " " + newx);
        return self.move_to(newx, d3.select(".glasswindow"));
      };
      viewdrag.on("drag", move_window);
      return this.minisvg.on("click", move_window);
    };

    return RoadmapD3;

  })();

}).call(this);
